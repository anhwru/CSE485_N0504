{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PhoneNumberSearch = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.default = findPhoneNumbers;\nexports.searchPhoneNumbers = searchPhoneNumbers;\nexports.sort_out_arguments = sort_out_arguments;\n\nvar _parse = require('./parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nvar _metadata = require('./metadata');\n\nvar _metadata2 = _interopRequireDefault(_metadata);\n\nvar _common = require('./common');\n\nvar _parsePreCandidate = require('./findNumbers/parsePreCandidate');\n\nvar _parsePreCandidate2 = _interopRequireDefault(_parsePreCandidate);\n\nvar _isValidPreCandidate = require('./findNumbers/isValidPreCandidate');\n\nvar _isValidPreCandidate2 = _interopRequireDefault(_isValidPreCandidate);\n\nvar _isValidCandidate = require('./findNumbers/isValidCandidate');\n\nvar _isValidCandidate2 = _interopRequireDefault(_isValidCandidate);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Copy-pasted from `./parse.js`.\n\n\nvar VALID_PHONE_NUMBER = '[' + _common.PLUS_CHARS + ']{0,1}' + '(?:' + '[' + _common.VALID_PUNCTUATION + ']*' + '[' + _common.VALID_DIGITS + ']' + '){3,}' + '[' + _common.VALID_PUNCTUATION + _common.VALID_DIGITS + ']*';\nvar EXTN_PATTERNS_FOR_PARSING = (0, _common.create_extension_pattern)('parsing');\nvar WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + _common.WHITESPACE + ']+');\nvar PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + _common.VALID_PUNCTUATION + ']+$'); // // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nvar VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;\n\nfunction findPhoneNumbers(arg_1, arg_2, arg_3, arg_4) {\n  var _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3, arg_4),\n      text = _sort_out_arguments.text,\n      options = _sort_out_arguments.options,\n      metadata = _sort_out_arguments.metadata;\n\n  var search = new PhoneNumberSearch(text, options, metadata.metadata);\n  var phones = [];\n\n  while (search.hasNext()) {\n    phones.push(search.next());\n  }\n\n  return phones;\n}\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\n\n\nfunction searchPhoneNumbers(arg_1, arg_2, arg_3, arg_4) {\n  var _sort_out_arguments2 = sort_out_arguments(arg_1, arg_2, arg_3, arg_4),\n      text = _sort_out_arguments2.text,\n      options = _sort_out_arguments2.options,\n      metadata = _sort_out_arguments2.metadata;\n\n  var search = new PhoneNumberSearch(text, options, metadata.metadata);\n  return _defineProperty({}, Symbol.iterator, function () {\n    return {\n      next: function next() {\n        if (search.hasNext()) {\n          return {\n            done: false,\n            value: search.next()\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  });\n}\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\n\n\nvar PhoneNumberSearch = exports.PhoneNumberSearch = function () {\n  function PhoneNumberSearch(text) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var metadata = arguments[2];\n\n    _classCallCheck(this, PhoneNumberSearch);\n\n    this.state = 'NOT_READY';\n    this.text = text;\n    this.options = options;\n    this.metadata = metadata;\n    this.regexp = new RegExp(VALID_PHONE_NUMBER + // Phone number extensions\n    '(?:' + EXTN_PATTERNS_FOR_PARSING + ')?', 'ig'); // this.searching_from = 0\n  } // Iteration tristate.\n\n\n  _createClass(PhoneNumberSearch, [{\n    key: 'find',\n    value: function find() {\n      var matches = this.regexp.exec(this.text);\n\n      if (!matches) {\n        return;\n      }\n\n      var number = matches[0];\n      var startsAt = matches.index;\n      number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');\n      startsAt += matches[0].length - number.length; // Fixes not parsing numbers with whitespace in the end.\n      // Also fixes not parsing numbers with opening parentheses in the end.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/252\n\n      number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');\n      number = (0, _parsePreCandidate2.default)(number);\n      var result = this.parseCandidate(number, startsAt);\n\n      if (result) {\n        return result;\n      } // Tail recursion.\n      // Try the next one if this one is not a valid phone number.\n\n\n      return this.find();\n    }\n  }, {\n    key: 'parseCandidate',\n    value: function parseCandidate(number, startsAt) {\n      if (!(0, _isValidPreCandidate2.default)(number, startsAt, this.text)) {\n        return;\n      } // Don't parse phone numbers which are non-phone numbers\n      // due to being part of something else (e.g. a UUID).\n      // https://github.com/catamphetamine/libphonenumber-js/issues/213\n      // Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\n\n      if (!(0, _isValidCandidate2.default)(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\n        return;\n      } // // Prepend any opening brackets left behind by the\n      // // `PHONE_NUMBER_START_PATTERN` regexp.\n      // const text_before_number = text.slice(this.searching_from, startsAt)\n      // const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n      // if (full_number_starts_at >= 0)\n      // {\n      // \tnumber   = text_before_number.slice(full_number_starts_at) + number\n      // \tstartsAt = full_number_starts_at\n      // }\n      //\n      // this.searching_from = matches.lastIndex\n\n\n      var result = (0, _parse2.default)(number, this.options, this.metadata);\n\n      if (!result.phone) {\n        return;\n      }\n\n      result.startsAt = startsAt;\n      result.endsAt = startsAt + number.length;\n      return result;\n    }\n  }, {\n    key: 'hasNext',\n    value: function hasNext() {\n      if (this.state === 'NOT_READY') {\n        this.last_match = this.find();\n\n        if (this.last_match) {\n          this.state = 'READY';\n        } else {\n          this.state = 'DONE';\n        }\n      }\n\n      return this.state === 'READY';\n    }\n  }, {\n    key: 'next',\n    value: function next() {\n      // Check the state and find the next match as a side-effect if necessary.\n      if (!this.hasNext()) {\n        throw new Error('No next element');\n      } // Don't retain that memory any longer than necessary.\n\n\n      var result = this.last_match;\n      this.last_match = null;\n      this.state = 'NOT_READY';\n      return result;\n    }\n  }]);\n\n  return PhoneNumberSearch;\n}();\n\nfunction sort_out_arguments(arg_1, arg_2, arg_3, arg_4) {\n  var text = void 0;\n  var options = void 0;\n  var metadata = void 0; // If the phone number is passed as a string.\n  // `parse('88005553535', ...)`.\n\n  if (typeof arg_1 === 'string') {\n    text = arg_1;\n  } else throw new TypeError('A text for parsing must be a string.'); // If \"default country\" argument is being passed\n  // then move it to `options`.\n  // `findNumbers('88005553535', 'RU', [options], metadata)`.\n\n\n  if ((typeof arg_2 === 'undefined' ? 'undefined' : _typeof(arg_2)) !== 'object') {\n    if (arg_4) {\n      options = _extends({\n        defaultCountry: arg_2\n      }, arg_3);\n      metadata = arg_4;\n    } else {\n      options = {\n        defaultCountry: arg_2\n      };\n      metadata = arg_3;\n    }\n  } // No \"default country\" argument is being passed.\n  // Only international phone numbers are passed.\n  // `findNumbers('+78005553535', [options], metadata)`.\n  else {\n      if (arg_3) {\n        options = arg_2;\n        metadata = arg_3;\n      } else {\n        metadata = arg_2;\n      }\n    }\n\n  if (!options) {\n    options = {};\n  } // // Apply default options.\n  // if (options)\n  // {\n  // \toptions = { ...default_options, ...options }\n  // }\n  // else\n  // {\n  // \toptions = default_options\n  // }\n\n\n  return {\n    text: text,\n    options: options,\n    metadata: new _metadata2.default(metadata)\n  };\n}","map":null,"metadata":{},"sourceType":"script"}